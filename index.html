<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Velocity Rush - 3D Racing</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            color: white;
            font-weight: bold;
        }

        #speedometer {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px 30px;
            border-radius: 15px;
            border: 3px solid #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        #speed {
            font-size: 48px;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }

        #speedLabel {
            font-size: 14px;
            color: #aaa;
            text-align: center;
        }

        #score {
            position: absolute;
            top: 30px;
            left: 30px;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid #ff6b6b;
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
        }

        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: all;
        }

        #gameOverScreen {
            display: none;
        }

        h1 {
            font-size: 72px;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #00ff88, #00d4ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        button {
            font-size: 24px;
            padding: 15px 40px;
            margin: 10px;
            border: none;
            border-radius: 50px;
            background: linear-gradient(45deg, #00ff88, #00d4ff);
            color: #000;
            font-weight: bold;
            cursor: pointer;
            pointer-events: all;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(0, 255, 136, 0.6);
        }

        button:active {
            transform: translateY(-1px);
        }

        .instructions {
            margin-top: 30px;
            font-size: 18px;
            color: #aaa;
            text-align: center;
        }

        #finalScore {
            font-size: 36px;
            margin: 20px 0;
            color: #00ff88;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <div id="score">
            <div style="margin-bottom: 10px;">You: <span id="scoreValue">0</span>m</div>
            <div style="color: #00d4ff;">Bot: <span id="botScoreValue">0</span>m</div>
        </div>
        <div id="speedometer">
            <div id="speed">0</div>
            <div id="speedLabel">KM/H</div>
        </div>
    </div>

    <div id="startScreen">
        <h1>VELOCITY RUSH</h1>
        <p class="instructions">Use Arrow Keys or A/D to steer<br>Avoid obstacles and drive as far as you can!</p>
        <button onclick="startGame()">START RACE</button>
    </div>

    <div id="gameOverScreen">
        <h1>RACE OVER</h1>
        <div id="finalScore"></div>
        <button onclick="restartGame()">RACE AGAIN</button>
    </div>

    <script>
        let scene, camera, renderer;
        let car, botCar, road, obstacles = [];
        let gameRunning = false;
        let score = 0;
        let botScore = 0;
        let speed = 0;
        let carPosition = 0;
        let botPosition = 0;
        let obstacleSpeed = 0.15;
        const maxSpeed = 180;
        const acceleration = 0.3;

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87ceeb, 10, 100);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 12);
            camera.lookAt(0, 0, -10);

            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('gameCanvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            scene.add(dirLight);

            createCar();
            createBotCar();
            createRoad();
            createEnvironment();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', handleKeyDown);
        }

        function createCar() {
            const carGroup = new THREE.Group();

            // Smooth rounded body
            const bodyGeometry = new THREE.SphereGeometry(0.8, 32, 32);
            bodyGeometry.scale(1.8, 0.6, 1.8);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0xff0000,
                shininess: 100,
                flatShading: false
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            carGroup.add(body);

            // Smooth rounded cabin
            const cabinGeometry = new THREE.SphereGeometry(0.65, 32, 32);
            cabinGeometry.scale(1.3, 0.8, 1);
            const cabinMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a1a1a,
                shininess: 120,
                flatShading: false
            });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabin.position.set(0, 1, -0.2);
            cabin.castShadow = true;
            carGroup.add(cabin);

            // Smooth wheels
            const wheelGeometry = new THREE.SphereGeometry(0.35, 24, 24);
            wheelGeometry.scale(0.4, 1, 1);
            const wheelMaterial = new THREE.MeshPhongMaterial({
                color: 0x111111,
                flatShading: false
            });

            const wheelPositions = [
                [-0.7, 0.3, 0.9],
                [0.7, 0.3, 0.9],
                [-0.7, 0.3, -0.9],
                [0.7, 0.3, -0.9]
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(...pos);
                wheel.castShadow = true;
                carGroup.add(wheel);

                // Add wheel rims
                const rimGeometry = new THREE.TorusGeometry(0.25, 0.05, 16, 32);
                const rimMaterial = new THREE.MeshPhongMaterial({
                    color: 0xcccccc,
                    flatShading: false
                });
                const rim = new THREE.Mesh(rimGeometry, rimMaterial);
                rim.rotation.y = Math.PI / 2;
                rim.position.set(pos[0] > 0 ? pos[0] + 0.05 : pos[0] - 0.05, pos[1], pos[2]);
                carGroup.add(rim);
            });

            // Add headlights
            const headlightGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const headlightMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffaa,
                emissive: 0xffffaa,
                emissiveIntensity: 0.8,
                flatShading: false
            });

            [-0.5, 0.5].forEach(x => {
                const headlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
                headlight.position.set(x, 0.5, 1.3);
                carGroup.add(headlight);
            });

            carGroup.position.y = 0.3;
            carGroup.position.z = 3;
            scene.add(carGroup);
            car = carGroup;
        }

        function createBotCar() {
            const carGroup = new THREE.Group();

            // Smooth rounded body
            const bodyGeometry = new THREE.SphereGeometry(0.8, 32, 32);
            bodyGeometry.scale(1.8, 0.6, 1.8);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0x0066ff,
                shininess: 100,
                flatShading: false
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            carGroup.add(body);

            // Smooth rounded cabin
            const cabinGeometry = new THREE.SphereGeometry(0.65, 32, 32);
            cabinGeometry.scale(1.3, 0.8, 1);
            const cabinMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a1a1a,
                shininess: 120,
                flatShading: false
            });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabin.position.set(0, 1, -0.2);
            cabin.castShadow = true;
            carGroup.add(cabin);

            // Smooth wheels
            const wheelGeometry = new THREE.SphereGeometry(0.35, 24, 24);
            wheelGeometry.scale(0.4, 1, 1);
            const wheelMaterial = new THREE.MeshPhongMaterial({
                color: 0x111111,
                flatShading: false
            });

            const wheelPositions = [
                [-0.7, 0.3, 0.9],
                [0.7, 0.3, 0.9],
                [-0.7, 0.3, -0.9],
                [0.7, 0.3, -0.9]
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(...pos);
                wheel.castShadow = true;
                carGroup.add(wheel);

                // Add wheel rims
                const rimGeometry = new THREE.TorusGeometry(0.25, 0.05, 16, 32);
                const rimMaterial = new THREE.MeshPhongMaterial({
                    color: 0xcccccc,
                    flatShading: false
                });
                const rim = new THREE.Mesh(rimGeometry, rimMaterial);
                rim.rotation.y = Math.PI / 2;
                rim.position.set(pos[0] > 0 ? pos[0] + 0.05 : pos[0] - 0.05, pos[1], pos[2]);
                carGroup.add(rim);
            });

            // Add headlights
            const headlightGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const headlightMaterial = new THREE.MeshPhongMaterial({
                color: 0xaaaaff,
                emissive: 0xaaaaff,
                emissiveIntensity: 0.8,
                flatShading: false
            });

            [-0.5, 0.5].forEach(x => {
                const headlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
                headlight.position.set(x, 0.5, 1.3);
                carGroup.add(headlight);
            });

            carGroup.position.y = 0.3;
            carGroup.position.z = 3;
            carGroup.position.x = -2.5;
            scene.add(carGroup);
            botCar = carGroup;
        }

        function createRoad() {
            const roadGroup = new THREE.Group();

            const roadGeometry = new THREE.PlaneGeometry(8, 200);
            const roadMaterial = new THREE.MeshPhongMaterial({
                color: 0x333333,
                side: THREE.DoubleSide
            });
            const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            roadMesh.rotation.x = -Math.PI / 2;
            roadMesh.receiveShadow = true;
            roadGroup.add(roadMesh);

            const lineGeometry = new THREE.PlaneGeometry(0.2, 3);
            const lineMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide
            });

            for (let i = 0; i < 30; i++) {
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.x = -Math.PI / 2;
                line.position.z = -i * 7;
                line.position.y = 0.02;
                roadGroup.add(line);
            }

            const grassGeometry = new THREE.PlaneGeometry(100, 200);
            const grassMaterial = new THREE.MeshPhongMaterial({
                color: 0x228b22,
                side: THREE.DoubleSide
            });
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.rotation.x = -Math.PI / 2;
            grass.position.y = -0.1;
            grass.receiveShadow = true;
            roadGroup.add(grass);

            scene.add(roadGroup);
            road = roadGroup;
        }

        function createEnvironment() {
            for (let i = 0; i < 20; i++) {
                // Smooth rounded tree tops
                const treeTopGeometry = new THREE.SphereGeometry(1.2, 32, 32);
                const treeTopMaterial = new THREE.MeshPhongMaterial({
                    color: 0x228b22,
                    flatShading: false
                });
                const treeTop = new THREE.Mesh(treeTopGeometry, treeTopMaterial);
                treeTop.position.set(
                    Math.random() > 0.5 ? 15 : -15,
                    2.2,
                    -i * 10 - Math.random() * 5
                );
                treeTop.castShadow = true;
                scene.add(treeTop);

                // Smooth tree trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.35, 1.5, 16);
                const trunkMaterial = new THREE.MeshPhongMaterial({
                    color: 0x8b4513,
                    flatShading: false
                });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(
                    treeTop.position.x,
                    0.75,
                    treeTop.position.z
                );
                trunk.castShadow = true;
                scene.add(trunk);
            }
        }

        function createObstacle() {
            const types = ['sphere', 'cone', 'cylinder'];
            const type = types[Math.floor(Math.random() * types.length)];

            let obstacle;
            if (type === 'sphere') {
                const geometry = new THREE.SphereGeometry(0.6, 32, 32);
                const material = new THREE.MeshPhongMaterial({
                    color: Math.random() * 0xffffff,
                    flatShading: false
                });
                obstacle = new THREE.Mesh(geometry, material);
                obstacle.position.y = 0.6;
            } else if (type === 'cone') {
                const geometry = new THREE.ConeGeometry(0.6, 1.5, 32);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xff6600,
                    flatShading: false
                });
                obstacle = new THREE.Mesh(geometry, material);
                obstacle.position.y = 0.75;
            } else {
                const geometry = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 32);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xffcc00,
                    flatShading: false
                });
                obstacle = new THREE.Mesh(geometry, material);
                obstacle.position.y = 0.6;
            }

            const lanes = [-2.5, 0, 2.5];
            obstacle.position.x = lanes[Math.floor(Math.random() * lanes.length)];
            obstacle.position.z = -50;
            obstacle.castShadow = true;

            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        function handleKeyDown(e) {
            if (!gameRunning) return;

            if ((e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') && carPosition > -1) {
                carPosition = Math.max(carPosition - 1, -1);
            }
            if ((e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') && carPosition < 1) {
                carPosition = Math.min(carPosition + 1, 1);
            }
        }

        function startGame() {
            const startScreen = document.getElementById('startScreen');
            if (startScreen) startScreen.style.display = 'none';

            gameRunning = true;
            score = 0;
            botScore = 0;
            speed = 0;
            carPosition = 1;  // Start in right lane
            botPosition = -1; // Start in left lane
            car.position.x = 2.5;
            botCar.position.x = -2.5;
            obstacles.forEach(obs => scene.remove(obs));
            obstacles = [];
            animate();
        }

        function restartGame() {
            const gameOverScreen = document.getElementById('gameOverScreen');
            if (gameOverScreen) gameOverScreen.style.display = 'none';

            car.position.x = 2.5;
            botCar.position.x = -2.5;
            startGame();
        }

        function gameOver() {
            gameRunning = false;
            const youWon = score > botScore;
            const finalScoreEl = document.getElementById('finalScore');
            const winnerEl = document.getElementById('winner');

            if (finalScoreEl) {
                finalScoreEl.textContent = `Your Distance: ${score}m | Bot Distance: ${botScore}m`;
            }
            if (winnerEl) {
                winnerEl.textContent = youWon ? '🏆 YOU WIN! 🏆' : '🤖 BOT WINS! 🤖';
            }

            const gameOverScreen = document.getElementById('gameOverScreen');
            if (gameOverScreen) {
                gameOverScreen.style.display = 'flex';
            }
        }

        function checkCollision() {
            for (let obs of obstacles) {
                // Check player collision
                const playerDistance = Math.sqrt(
                    Math.pow(car.position.x - obs.position.x, 2) +
                    Math.pow(car.position.z - obs.position.z, 2)
                );

                if (playerDistance < 2) {
                    return 'player';
                }

                // Check bot collision
                const botDistance = Math.sqrt(
                    Math.pow(botCar.position.x - obs.position.x, 2) +
                    Math.pow(botCar.position.z - obs.position.z, 2)
                );

                if (botDistance < 2) {
                    return 'bot';
                }
            }
            return false;
        }

        function animate() {
            if (!gameRunning) return;

            requestAnimationFrame(animate);

            speed = Math.min(speed + acceleration, maxSpeed);
            obstacleSpeed = 0.15 + (speed / maxSpeed) * 0.25;

            // Player car movement (lanes: -2.5, 0, 2.5 mapped from carPosition: -1, 0, 1)
            const targetX = carPosition * 2.5;
            car.position.x += (targetX - car.position.x) * 0.1;

            // Bot AI - simple obstacle avoidance
            let closestObstacle = null;
            let closestDistance = Infinity;

            obstacles.forEach(obs => {
                if (obs.position.z > botCar.position.z - 15 && obs.position.z < botCar.position.z + 5) {
                    const dist = Math.abs(obs.position.z - botCar.position.z);
                    if (dist < closestDistance) {
                        closestDistance = dist;
                        closestObstacle = obs;
                    }
                }
            });

            if (closestObstacle && closestDistance < 12) {
                // Move away from obstacle
                if (Math.abs(botCar.position.x - closestObstacle.position.x) < 1.5) {
                    if (botCar.position.x > closestObstacle.position.x && botPosition < 1) {
                        botPosition = Math.min(botPosition + 0.15, 1);
                    } else if (botCar.position.x < closestObstacle.position.x && botPosition > -1) {
                        botPosition = Math.max(botPosition - 0.15, -1);
                    }
                }
            } else {
                // Random lane changes occasionally
                if (Math.random() < 0.008) {
                    botPosition = [-1, 0, 1][Math.floor(Math.random() * 3)];
                }
            }

            const botTargetX = botPosition * 2.5;
            botCar.position.x += (botTargetX - botCar.position.x) * 0.08;

            road.position.z += obstacleSpeed;
            if (road.position.z > 7) {
                road.position.z = 0;
            }

            obstacles.forEach(obs => {
                obs.position.z += obstacleSpeed;
            });

            obstacles = obstacles.filter(obs => {
                if (obs.position.z > 10) {
                    scene.remove(obs);
                    return false;
                }
                return true;
            });

            if (Math.random() < 0.01) {
                createObstacle();
            }

            const collision = checkCollision();
            if (collision) {
                gameOver();
                return;
            }

            score += Math.floor(speed / 10);
            botScore += Math.floor(speed / 10);

            const scoreEl = document.getElementById('scoreValue');
            const botScoreEl = document.getElementById('botScoreValue');
            const speedEl = document.getElementById('speed');

            if (scoreEl) scoreEl.textContent = score;
            if (botScoreEl) botScoreEl.textContent = botScore;
            if (speedEl) speedEl.textContent = Math.floor(speed);

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
